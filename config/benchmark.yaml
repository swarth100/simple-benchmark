reference_module: "benchmarks.reference"

user_modules:
  - "benchmarks.team01"
  - "benchmarks.team02"
  - "benchmarks.team03"

benchmarks:
  - function_name: "square"
    description: Print a square of a given size.
    max_time: 100000
    difficulty: 1.5
    args:
      - name: "size"
        description: "The size of the square's sides."
        increment: "lambda x: x + 1"
        default: "int(1)"
        example: "int(4)"

  - function_name: "triangle"
    description: Print a right-angled triangle with stars.
    max_time: 100000
    difficulty: 2.0
    args:
      - name: "size"
        description: "The height of the triangle."
        increment: "lambda x: x + 1"
        default: "int(1)"
        example: "int(4)"

  - function_name: "rhombus"
    description: Print a rhombus pattern.
    max_time: 100000
    difficulty: 2.5
    args:
      - name: "size"
        description: "The size of the rhombus."
        increment: "lambda x: x + 1"
        default: "int(1)"
        example: "int(5)"

  - function_name: "running_sum"
    description: Return the (cumulative) running sum of a list.
    max_time: 50000
    difficulty: 2.0
    args:
      - name: "size"
        increment: "lambda x: x + 1"
        default: "int(1)"
        hidden: true
      - name: "nums"
        description: "The list of integers for calculating the running sum."
        increment: "lambda **kwargs: [random.randint(0, 100) for _ in range(kwargs['size'])]"
        default: "list([2,5,3,1])"

  - function_name: "histogram"
    description: Print a histogram from a list of numbers.
    max_time: 50000
    difficulty: 2.5
    args:
      - name: "size"
        increment: "lambda x: x + 1"
        default: "int(1)"
        hidden: true
      - name: "nums"
        description: "The list of numbers for generating a histogram."
        increment: "lambda **kwargs: [random.randint(0, 10) for _ in range(kwargs['size'])]"
        default: "list([4,1,2])"

  - function_name: "scatter"
    description: Print a scatter plot of points of a given size.
    max_time: 50000
    difficulty: 3.0
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(3)"
        hidden: true
      - name: "size"
        description: "The size of the scatter plot."
        increment: "lambda **kwargs: int(kwargs['x'] ** 0.65)"
        default: "int(4)"
      - name: "points"
        description: "The list of points as tuples for the scatter plot."
        increment: "lambda **kwargs: [[random.randint(1, kwargs['size']), random.randint(1, kwargs['size'])] for _ in range(random.randint(1, kwargs['size'] + 1))]"
        default: "list([[2,2],[1,3],[4,1]])"

  - function_name: "count_pairs"
    description: Given a list of pairs `nums`, return the count of pairs of numbers that differ by a specific amount (`k`).
    max_time: 50000
    difficulty: 2.5
    args:
      - name: "size"
        increment: "lambda x: x + 1"
        default: "int(1)"
        hidden: true
      - name: "nums"
        description: "The list of numbers to count pairs from."
        increment: "lambda **kwargs: [random.randint(0, kwargs['size'] // 2) for _ in range(kwargs['size'])]"
        default: "list([1,2,2,1])"
      - name: "k"
        description: "The difference value for counting pairs."
        increment: "lambda **kwargs: random.randint(1, kwargs['size'] // 2)"
        default: "int(1)"

  - function_name: "dividing_numbers"
    description: Return a list of all self-dividing numbers in a range.
    max_time: 50000
    difficulty: 2.5
    args:
      - name: "size"
        increment: "lambda x: x + 1"
        default: "int(10)"
        hidden: true
      - name: "left"
        description: "The left boundary of the range."
        increment: "lambda **kwargs: random.randint(0, kwargs['size'] // 2)"
        default: "int(0)"
      - name: "right"
        description: "The right boundary of the range."
        increment: "lambda **kwargs: random.randint(kwargs['size'] // 2, kwargs['size'])"
        default: "int(10)"

  - function_name: "generate_trajectory"
    description: Print the trajectory of a projectile which is launched with a given `angle` and `velocity`.
    max_time: 50000
    difficulty: 4.0
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(25)"
        hidden: true
      - name: "velocity"
        description: "The initial velocity of the projectile."
        increment: "lambda **kwargs: int(kwargs['x'] * (0.1 + random.random()))"
        default: "int(15)"
      - name: "angle"
        description: "The angle of projection."
        increment: "lambda angle: int(45 + (random.random() - 0.5) * 45)"
        default: "int(45)"
      - name: "size"
        description: "The size of the simulation area."
        increment: "lambda **kwargs: [random.randint(kwargs['x'], int(kwargs['x'] * 1.5)), random.randint(kwargs['x'] // 3, kwargs['x'] // 1.5)]"
        default: "list([25, 8])"

  - function_name: "sort_by_height"
    description: |
      Return a list of people sorted by corresponding heights.
      Tallest person first.
    max_time: 10000
    difficulty: 2.0
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(1)"
        hidden: true
      - name: "names"
        description: "The list of names."
        increment: "lambda **kwargs: list(set([fake.first_name() for _ in range(kwargs['x'])]))"
        default: "list(['Alice', 'Bob', 'Charlie'])"
      - name: "heights"
        description: "The list of corresponding heights."
        increment: "lambda **kwargs: [random.randint(150, 200) for _ in range(len(kwargs['names']))]"
        default: "list([165, 180, 175])"

  - function_name: "best_student"
    description: Given a dictionary of students and their grades, return the name of the student with the highest average grade.
    max_time: 15000
    difficulty: 3.0
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(1)"
        hidden: true
      - name: "offsets"
        increment: "lambda **kwargs: [random.randint(2, 7) for _ in range(kwargs['x'])]"
        default: "list([4, 5, 4])"
        hidden: true
      - name: "gradebook"
        description: "The dictionary containing student names and their grades."
        increment: "lambda **kwargs: {
                      fake.first_name(): [
                        round(random.uniform(0, 3) + kwargs['offsets'][idx], 1) for _ in range(random.randint(1, int(kwargs['x'] ** 1.15 // 3 + 1)))
                      ] for idx in range(kwargs['x'])
                    }"
        default: "dict({'Alice': [8, 7.5, 8.8],'Bob': [8, 9],'Charlie': [6.2, 7.5]})"

  - function_name: "can_visit_all_rooms"
    description: |
      You are given a dictionary of room names and all the rooms are locked except for the `unlocked` room in the dictionary.
      Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.<br><br>
      
      When you visit a room, you may find a list of distinct keys in it. 
      Each key has a room name on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.<br><br>
      
      Given a dictionary of rooms where `rooms[name]` is the list of keys that you can obtain if you visited room `name`, return `True` if you can visit all the rooms, or `False` otherwise.
    max_time: 5000
    difficulty: 4.5
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(1)"
        hidden: true
      - name: "names"
        increment: "lambda **kwargs: [fake.safe_color_name().title() for _ in range(kwargs['x'] + 1)]"
        default: "list(['Red', 'Green', 'Blue'])"
        hidden: true
      - name: "unlocked"
        description: "The name of the only unlocked room (to start with)."
        increment: "lambda **kwargs: kwargs['names'][random.randint(0, kwargs['x'])]"
        default: "str('Red')"
      - name: "rooms"
        description: "The dictionary of all rooms and keys."
        increment: "lambda **kwargs: {
                      name: list(set([kwargs['names'][random.randint(0, kwargs['x'])] for x in range(random.randint(0, int(kwargs['x'] ** 0.5 + 2)))]) - {name})
                      for name in kwargs['names']
                    }"
        default: "dict({'Red': ['Green'], 'Blue': ['Red', 'Green'], 'Green': ['Blue']})"

  - function_name: "jobs_counter"
    description: Return a dictionary with the count of occurrences for each job in a list.
    max_time: 10000
    difficulty: 2.0
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(3)"
        hidden: true
      - name: "elems"
        increment: "lambda **kwargs: [fake.job() for _ in range(int(kwargs['x'] ** 0.5))]"
        default: "list(['artist', 'doctor', 'professor'])"
        hidden: true
      - name: "jobs"
        description: "The list of jobs."
        increment: "lambda **kwargs: [
                      kwargs['elems'][int(random.randint(0, len(kwargs['elems']) - 1))] for _ in range(int(kwargs['x'] ** 1.15))
                    ]"
        default: "list(['doctor', 'professor', 'artist', 'professor', 'professor', 'artist'])"

  - function_name: "smallest_number"
    description: |
      Create a function that given three numbers returns the smallest number of the three.
    max_time: 2000
    difficulty: 0.5
    args:
      - name: "x"
        increment: "lambda **kwargs: random.randint(-100, 100)"
        description: "The first number."
        default: "int(12)"
      - name: "y"
        increment: "lambda **kwargs: random.randint(-100, 100)"
        description: "The second number."
        default: "int(4)"
      - name: "z"
        increment: "lambda **kwargs: random.randint(-100, 100)"
        description: "The third number."
        default: "int(87)"

  - function_name: "complementary_dna"
    description: |
      Create a function that converts a sequence of nucleotides (*Adenine* `A`, *Cytosine* `C`, *Thymine* `T`, *Guanine* `G`) contained in an input vector of indefinite length into its complementary sequence (`Adenine --> Thymine`, `Thymine --> Adenine`, `Cytosine --> Guanine`, `Guanine --> Cytosine`).<br>
      
      The function returns a list of characters with the converted sequence.
    max_time: 10000
    difficulty: 1.5
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(0)"
        hidden: true
      - name: "sequence"
        description: "The input list containing the nucleotide sequence as a list of characters."
        increment: "lambda **kwargs: [random.choice(['A', 'T', 'C', 'G']) for _ in range(kwargs['x'])]"
        default: "list(['A','A','C','G','T'])"

  - function_name: "calculate_discount"
    description: |
      Create a function that calculates the final price after applying a discount percentage to all the items in the `shopping` list. The function should return the final price which is the sum of all the discounted items in `shopping`.
    max_time: 3000
    difficulty: 2.5
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(0)"
        hidden: true
      - name: "shopping"
        description: "The list of items to apply the discount to."
        increment: "lambda **kwargs: [random.randint(1, 1000) / 10 for _ in range(kwargs['x'])]"
        default: "list([10.5, 8.7, 30])"
      - name: "discount"
        description: "The discount percentage to apply to all items."
        increment: "lambda **kwargs: random.randint(1, 19) * 5"
        default: "int(20)"

  - function_name: "even_numbers"
    description: |
      Create a function that given a list of integers, returns a new list containing only the even numbers from the original list.
    max_time: 4000
    difficulty: 1.5
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(0)"
        hidden: true
      - name: "numbers"
        description: "The list of integers to filter."
        increment: "lambda **kwargs: [random.randint(1, 100) for _ in range(kwargs['x'])]"
        default: "list([1, 2, 3, 4, 5])"

  - function_name: "city_life"
    description: |
      Create a function that given two sets of people, the set of people that live in `turin` and the set of people that live in `milan`, returns the `set` of people that live both in `turin` and `milan`.
    max_time: 2000
    difficulty: 1.0
    args:
      - name: "size"
        increment: "lambda x: x + 1"
        default: "int(4)"
        hidden: true
      - name: "people"
        increment: "lambda **kwargs: list({fake.first_name() for _ in range(kwargs['size'] * 2)})"
        default: "set(['Adam', 'Charlie', 'Roger', 'Zethus'])"
        hidden: true
      - name: "turin"
        description: "The set of people that live in Turin."
        increment: "lambda **kwargs: {random.choice(kwargs['people'])  for _ in range(kwargs['size'])}"
        default: "set(['Adam', 'Roger', 'Zethus'])"
      - name: "milan"
        description: "The set of people that live in Milan."
        increment: "lambda **kwargs: {random.choice(kwargs['people'])  for _ in range(kwargs['size'])}"
        default: "set(['Charlie', 'Roger', 'Zethus'])"

  - function_name: "prime_factors"
    description: |
      Create a function that decomposes a `number` into its prime factors.<br>
      The function returns a list with all prime factors of the input `number` in ascending order.
    max_time: 10000
    difficulty: 2.5
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(0)"
        hidden: true
      - name: "number"
        description: "The number to be decomposed into prime factors."
        increment: "lambda **kwargs: kwargs['number'] + random.randint(1, int(kwargs['x'] ** 0.5))"
        default: "int(1)"
        example: "int(30)"

  - function_name: "partitioning_line"
    description: |
      Create a function that given two points `start` and `end` and a list of points to partition (`points`) returns a list of all points that are on or above the line passing through `start` and `end` (on a cartesian plane).<br>
      The function will return points that lie on or above the line and **not** return points that lie underneath the line.
    max_time: 10000
    difficulty: 3.0
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(0)"
        hidden: true
      - name: "start"
        description: "The start point of the line as a list of two coordinates `[x, y]`."
        increment: "lambda **kwargs: [random.randint(0, 10), random.randint(0, 10)]"
        default: "list([0, 0])"
      - name: "end"
        description: "The end point of the line as a list of two coordinates `[x, y]`."
        increment: "lambda **kwargs: [random.randint(0, 10), random.randint(0, 10)]"
        default: "list([10, 10])"
      - name: "points"
        description: "The list of points on the cartesian plane to partition as a list of lists of two coordinates `[x, y]`."
        increment: "lambda **kwargs: [[random.randint(-kwargs['x']-5, kwargs['x']+5), random.randint(-kwargs['x']-5, kwargs['x']+5)] for _ in range(int(kwargs['x'] ** 0.8))]"
        default: "list([[1, 2], [3, 1], [5, 5]])"

  - function_name: "pascal_triangle"
    description: |
      Given an input number `n`, return a list of lists containing the numbers of Pascal's Triangle up to the `n`th row.
    max_time: 100000
    difficulty: 3.5
    args:
      - name: "n"
        description: "The number of rows in Pascal's Triangle to generate."
        increment: "lambda x: x + 1"
        default: "int(1)"
        example: "int(5)"

  - function_name: "missing_triangle"
    description: |
      Print a right-angled triangle with given two sides, calculating the missing third side.<br>
      The sides are provided in a dictionary where two of the following are always present:
      * `cathetus1`: The vertical cathethus of the triangle
      * `cathetus2`: The horizontal cathetus of the triangle
      * `hypotenuse`: The hypothenuse of the right-angled triangle
    max_time: 10000
    difficulty: 3.5
    args:
      - name: "size"
        increment: "lambda x: x + 1"
        default: "int(3)"
        hidden: true
      - name: "hypothenuse"
        increment: "lambda **kwargs:  random.randint(kwargs['size'] // 2, kwargs['size'])"
        default: "int(5)"
        hidden: true
      - name: "sides"
        description: "A dictionary containing two sides of the triangle."
        increment: "lambda **kwargs: {'cathetus1': random.randint(1, kwargs['hypothenuse'] - 1), 'hypotenuse': kwargs['hypothenuse']} if random.random() < 0.5 else {'cathetus2': random.randint(1, kwargs['hypothenuse'] // 2), 'hypotenuse': kwargs['hypothenuse']}"
        default: "dict({'cathetus1': 3, 'hypotenuse': 5})"

  - function_name: "machine"
    description: |
      Process a list of commands to print characters, where:
      * `0` prints `.`
      * `1` prints `#`
      * `2` prints a newline.
    max_time: 10000
    difficulty: 1.5
    args:
      - name: "x"
        increment: "lambda x: x + random.randint(1, 3)"
        default: "int(1)"
        hidden: true
      - name: "commands"
        description: "A list of integer commands consisting of `0`s, `1`s and `2`s"
        increment: "lambda **kwargs: [random.randint(0, 2) for _ in range(kwargs['x'])] + [2]"
        default: "list([1, 0, 2, 0, 1, 1, 2])"

  - function_name: "smallest_city"
    description: |
      Given a list of `City` objects, return the instance of the `City` object with the smallest population.
    max_time: 2000
    difficulty: 1.5
    include:
      - "City"
    args:
      - name: "x"
        increment: "lambda x: x + random.randint(0, 2)"
        default: "int(1)"
        hidden: true
      - name: "cities"
        description: "A list of City objects."
        increment: "lambda **kwargs: [City(name=fake.city(), population=random.randint(1000, 1000000)) for _ in range(kwargs['x'])]"
        default: "list([City(name='New York', population=1000000), City(name='Los Angeles', population=500000), City(name='Chicago', population=250000)])"

  - function_name: "total_height"
    description: |
      Given two people, find the sum of their heights.
    max_time: 500
    difficulty: 0.5
    include:
      - "Person"
    args:
      - name: "person_a"
        increment: "lambda **kwargs: Person(name=fake.first_name(), height=random.randint(150, 210))"
        default: "Person(name='Carlo', height=180)"
      - name: "person_b"
        increment: "lambda **kwargs: Person(name=fake.first_name(), height=random.randint(150, 210))"
        default: "Person(name='Paola', height=165)"

  - function_name: "total_num_pages"
    description: |
      Given a list of `Book` objects, return the total number of pages across all books.
    max_time: 2000
    difficulty: 1.0
    include:
      - "Book"
    args:
      - name: "x"
        increment: "lambda x: x + random.randint(0, 2)"
        default: "int(1)"
        hidden: true
      - name: "books"
        description: "A list of Book objects."
        increment: "lambda **kwargs: [Book(title=fake.sentence(3), pages=random.randint(100, 1000)) for _ in range(kwargs['x'])]"
        default: "list([Book(title='The Great Gatsby', pages=200), Book(title='The Catcher in the Rye', pages=300), Book(title='To Kill a Mockingbird', pages=400)])"

  - function_name: "park_cars"
    description: |
      Given a list of `Car` objects (`garage`) and a list of license plates, the `park_cars` function should return the number of cars with the matching license plates that are not parked.
    max_time: 10000
    difficulty: 2.0
    include:
      - "Car"
    args:
      - name: "x"
        increment: "lambda x: x + random.randint(0, 2)"
        default: "int(1)"
        hidden: true
      - name: "l"
        increment: "lambda **kwargs: list({fake.license_plate() for _ in range(kwargs['x'])})"
        default: "list(['ABC123', 'DEF456', 'GHI789'])"
        hidden: true
      - name: "m"
        increment: "lambda **kwargs: [*kwargs['l']]"
        default: "list(['ABC123', 'DEF456', 'GHI789'])"
        hidden: true
      - name: "garage"
        description: "A list of Car objects."
        increment: "lambda **kwargs: [Car(license_plate=kwargs['l'].pop(), is_parked=random.choice([True, False])) for _ in range(len(kwargs['l']))]"
        default: "list([Car(license_plate='ABC123', is_parked=True), Car(license_plate='DEF456', is_parked=False), Car(license_plate='GHI789', is_parked=False)])"
      - name: "license_plates"
        description: "A list of license plates."
        increment: "lambda **kwargs: list({random.choice(kwargs['m']) for _ in range(kwargs['x'])})"
        default: "list(['ABC123', 'GHI789'])"

  - function_name: "calculate_gpa"
    description: |
      Given a list of `Student` objects and a student's name, calculate their GPA (assuming each grade is a numerical value), and return the GPA.
    max_time: 1000
    difficulty: 2.5
    include:
      - "Student"
    args:
      - name: "x"
        increment: "lambda x: x + random.randint(0, 2)"
        default: "int(1)"
        hidden: true
      - name: "n"
        increment: "lambda **kwargs: list({fake.first_name() for _ in range(kwargs['x'])})"
        default: "list(['Alice', 'Bob', 'Charlie'])"
        hidden: true
      - name: "m"
        increment: "lambda **kwargs: [*kwargs['n']]"
        default: "list(['Alice', 'Bob', 'Charlie'])"
        hidden: true
      - name: "students"
        description: "A list of Student objects."
        increment: "lambda **kwargs: [Student(name=kwargs['n'].pop(), grades=[random.randint(2, 10) for _ in range(random.randint(1, 5))]) for _ in range(len(kwargs['n']))]"
        default: "list([Student(name='Alice', grades=[9, 8, 7]), Student(name='Bob', grades=[8, 7, 6]), Student(name='Charlie', grades=[7, 6, 5])])"
      - name: "name"
        description: "The name of the student."
        increment: "lambda **kwargs: random.choice(kwargs['m'])"
        default: "str('Alice')"

  - class_name: "Coordinate"
    description: |
      Within a class `Coordinate` representing a point in a 2D plane.
      Implement a `distance` method to calculate the distance from another `Coordinate`.
    max_time: 500
    difficulty: 2.0
    init:
      - name: "size"
        increment: "lambda x: x + 1"
        default: "int(3)"
        hidden: true
      - name: "x"
        description: "The x-axis of the coordinate."
        increment: "lambda **kwargs: random.randint(-kwargs['size'], kwargs['size'])"
        default: "int(4)"
      - name: "y"
        description: "The y-axis of the coordinate."
        increment: "lambda **kwargs: random.randint(-kwargs['size'], kwargs['size'])"
        default: "int(2)"
    methods:
      - method_name: "distance"
        description: "Calculate the distance from another Coordinate."
        args:
          - name: "other"
            description: "The other Coordinate to calculate the distance from."
            increment: "lambda **kwargs: Coordinate(x=random.randint(-kwargs['size'], kwargs['size']), y=random.randint(-kwargs['size'], kwargs['size']))"
            default: "Coordinate(x=1, y=1)"
    evaluation:
      increment: "lambda **kwargs: list(['distance'])"
      default: "list(['distance'])"

  - class_name: "Warehouse"
    description: |
      You are given a class `Warehouse` representing a warehouse with number of products.
      You must implement a `add_products` method that adds a given amount of products to the warehouse.
      You must also implement a `remove_products` method that removes a given amount of products from the warehouse.
      You must implement a `get_products` method that returns the number of products in the warehouse.
    max_time: 200
    difficulty: 1.0
    init:
      - name: "size"
        increment: "lambda x: x + 1"
        default: "int(3)"
        hidden: true
      - name: "products"
        description: "The number of products in the warehouse."
        increment: "lambda **kwargs: random.randint(0, kwargs['size'])"
        default: "int(4)"
    methods:
      - method_name: "add_products"
        description: "Add a given amount of products to the warehouse."
        args:
          - name: "amount"
            description: "The amount of products to add."
            increment: "lambda **kwargs: random.randint(0, kwargs['size'])"
            default: "int(45)"
      - method_name: "remove_products"
        description: "Remove a given amount of products from the warehouse."
        args:
          - name: "amount"
            description: "The amount of products to remove. **NOTE**: The amount of products may not go negative."
            increment: "lambda **kwargs: random.randint(0, kwargs['size'])"
            default: "int(18)"
      - method_name: "get_products"
        description: "Get the number of products in the warehouse."
        args: [ ]
    evaluation:
      increment: "lambda **kwargs: [random.choice(['add_products', 'remove_products']) for _ in range(kwargs['size'])] + ['get_products']"
      default: "list(['add_products', 'remove_products', 'get_products'])"

  - class_name: "BookStore"
    description: |
      You are given a class `BookStore` representing a bookstore with a list of `Books`.
      You must implement a `add_book` method that adds a given `Book` object to the bookstore. You may get duplicate copies of the same book.
      You must implement a `get_num_copies` method that returns the number of copies of the specified `Book` stored in the bookstore.
    max_time: 3000
    difficulty: 1.5
    include:
      - "Book"
    init:
      - name: "size"
        increment: "lambda x: x + 1"
        default: "int(2)"
        hidden: true
      - name: "all_books"
        description: "The universe all all books."
        increment: "lambda **kwargs: [Book(title=fake.sentence(3), pages=random.randint(100, 1000)) for _ in range(kwargs['size'])]"
        default: "list([Book(title='The Great Gatsby', pages=200), Book(title='The Catcher in the Rye', pages=300), Book(title='To Kill a Mockingbird', pages=400)])"
        hidden: true
      - name: "books"
        description: "The list of books in the bookstore."
        increment: "lambda **kwargs: kwargs['all_books'][:kwargs['size'] // 2]"
        default: "list([Book(title='The Great Gatsby', pages=200), Book(title='The Catcher in the Rye', pages=300)])"
    methods:
      - method_name: "add_book"
        description: "Add a given Book object to the bookstore."
        args:
          - name: "book"
            description: "The Book object to add to the bookstore."
            increment: "lambda **kwargs: random.choice(kwargs['all_books'])"
            default: "Book(title='To Kill a Mockingbird', pages=400)"
      - method_name: "get_num_copies"
        description: "Get the number of copies of the specified Book stored in the bookstore."
        args:
          - name: "book"
            description: "The Book object to get the number of copies of. **NOTE**: The `Book` object may not be in the bookstore, or there may me duplicates of the same `Book`."
            increment: "lambda **kwargs: random.choice(kwargs['all_books'])"
            default: "Book(title='The Great Gatsby', pages=200)"
    evaluation:
      increment: "lambda **kwargs: ['add_book'] * (kwargs['size'] * 2) + ['get_num_copies']"
      default: "list(['add_book', 'get_num_copies'])"
