reference_module: "benchmarks.reference"

user_modules:
  - "benchmarks.team01"
  - "benchmarks.team02"
  - "benchmarks.team03"

benchmarks:
  - function_name: "square"
    description: Print a square of a given size.
    max_time: 100
    difficulty: 1.5
    args:
      - name: "size"
        description: "The size of the square's sides."
        increment: "lambda x: x + 1"
        default: "int(1)"
        example: "int(4)"

  - function_name: "triangle"
    description: Print a right-angled triangle with stars.
    max_time: 100
    difficulty: 2.0
    args:
      - name: "size"
        description: "The height of the triangle."
        increment: "lambda x: x + 1"
        default: "int(1)"
        example: "int(4)"

  - function_name: "rhombus"
    description: Print a rhombus pattern.
    max_time: 100
    difficulty: 2.5
    args:
      - name: "size"
        description: "The size of the rhombus."
        increment: "lambda x: x + 1"
        default: "int(1)"
        example: "int(5)"

  - function_name: "running_sum"
    description: Return the (cumulative) running sum of a list.
    max_time: 50
    difficulty: 2.0
    args:
      - name: "size"
        increment: "lambda x: x + 1"
        default: "int(1)"
        hidden: true
      - name: "nums"
        description: "The list of integers for calculating the running sum."
        increment: "lambda **kwargs: [random.randint(0, 100) for _ in range(kwargs['size'])]"
        default: "list([2,5,3,1])"

  - function_name: "histogram"
    description: Print a histogram from a list of numbers.
    max_time: 50
    difficulty: 2.5
    args:
      - name: "size"
        increment: "lambda x: x + 1"
        default: "int(1)"
        hidden: true
      - name: "nums"
        description: "The list of numbers for generating a histogram."
        increment: "lambda **kwargs: [random.randint(0, 10) for _ in range(kwargs['size'])]"
        default: "list([4,1,2])"

  - function_name: "scatter"
    description: Print a scatter plot of points of a given size.
    max_time: 50
    difficulty: 3.0
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(3)"
        hidden: true
      - name: "size"
        description: "The size of the scatter plot."
        increment: "lambda **kwargs: int(kwargs['x'] ** 0.65)"
        default: "int(4)"
      - name: "points"
        description: "The list of points as tuples for the scatter plot."
        increment: "lambda **kwargs: [[random.randint(1, kwargs['size']), random.randint(1, kwargs['size'])] for _ in range(random.randint(1, kwargs['size'] + 1))]"
        default: "list([[2,2],[1,3],[4,1]])"

  - function_name: "count_pairs"
    description: Given a list of pairs `nums`, return the count of pairs of numbers that differ by a specific amount (`k`).
    max_time: 50
    difficulty: 2.5
    args:
      - name: "size"
        increment: "lambda x: x + 1"
        default: "int(1)"
        hidden: true
      - name: "nums"
        description: "The list of numbers to count pairs from."
        increment: "lambda **kwargs: [random.randint(0, kwargs['size'] // 2) for _ in range(kwargs['size'])]"
        default: "list([1,2,2,1])"
      - name: "k"
        description: "The difference value for counting pairs."
        increment: "lambda **kwargs: random.randint(1, kwargs['size'] // 2)"
        default: "int(1)"

  - function_name: "dividing_numbers"
    description: Return a list of all self-dividing numbers in a range.
    max_time: 50
    difficulty: 2.5
    args:
      - name: "size"
        increment: "lambda x: x + 1"
        default: "int(10)"
        hidden: true
      - name: "left"
        description: "The left boundary of the range."
        increment: "lambda **kwargs: random.randint(0, kwargs['size'] // 2)"
        default: "int(0)"
      - name: "right"
        description: "The right boundary of the range."
        increment: "lambda **kwargs: random.randint(kwargs['size'] // 2, kwargs['size'])"
        default: "int(10)"

  - function_name: "generate_trajectory"
    description: Print the trajectory of a projectile which is launched with a given `angle` and `velocity`.
    max_time: 50
    difficulty: 4.0
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(25)"
        hidden: true
      - name: "velocity"
        description: "The initial velocity of the projectile."
        increment: "lambda **kwargs: int(kwargs['x'] * (0.1 + random.random()))"
        default: "int(15)"
      - name: "angle"
        description: "The angle of projection."
        increment: "lambda angle: int(45 + (random.random() - 0.5) * 45)"
        default: "int(45)"
      - name: "size"
        description: "The size of the simulation area."
        increment: "lambda **kwargs: [random.randint(kwargs['x'], int(kwargs['x'] * 1.5)), random.randint(kwargs['x'] // 3, kwargs['x'] // 1.5)]"
        default: "list([25, 8])"

  - function_name: "sort_by_height"
    description: |
      Return a list of people sorted by corresponding heights.
      Tallest person first.
    max_time: 10
    difficulty: 2.0
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(1)"
        hidden: true
      - name: "names"
        description: "The list of names."
        increment: "lambda **kwargs: list(set([fake.first_name() for _ in range(kwargs['x'])]))"
        default: "list(['Alice', 'Bob', 'Charlie'])"
      - name: "heights"
        description: "The list of corresponding heights."
        increment: "lambda **kwargs: [random.randint(150, 200) for _ in range(len(kwargs['names']))]"
        default: "list([165, 180, 175])"

  - function_name: "best_student"
    description: Given a dictionary of students and their grades, return the name of the student with the highest average grade.
    max_time: 15
    difficulty: 2.5
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(1)"
        hidden: true
      - name: "offsets"
        increment: "lambda **kwargs: [random.randint(2, 7) for _ in range(kwargs['x'])]"
        default: "list([4, 5, 4])"
        hidden: true
      - name: "gradebook"
        description: "The dictionary containing student names and their grades."
        increment: "lambda **kwargs: {
                      fake.first_name(): [
                        round(random.uniform(0, 3) + kwargs['offsets'][idx], 1) for _ in range(random.randint(1, int(kwargs['x'] ** 1.15 // 3 + 1)))
                      ] for idx in range(kwargs['x'])
                    }"
        default: "dict({'Alice': [8, 7.5, 8.8],'Bob': [8, 9],'Charlie': [6.2, 7.5]})"

  - function_name: "jobs_counter"
    description: Return a dictionary with the count of occurrences for each job in a list.
    max_time: 10
    difficulty: 1.5
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(3)"
        hidden: true
      - name: "elems"
        increment: "lambda **kwargs: [fake.job() for _ in range(int(kwargs['x'] ** 0.5))]"
        default: "list(['artist', 'doctor', 'professor'])"
        hidden: true
      - name: "jobs"
        description: "The list of jobs."
        increment: "lambda **kwargs: [
                      kwargs['elems'][int(random.randint(0, len(kwargs['elems']) - 1))] for _ in range(int(kwargs['x'] ** 1.15))
                    ]"
        default: "list(['doctor', 'professor', 'artist', 'professor', 'professor', 'artist'])"

  - function_name: "can_visit_all_rooms"
    description: |
      You are given a dictionary of room names and all the rooms are locked except for the `unlocked` room in the dictionary.
      Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.<br><br>
      
      When you visit a room, you may find a list of distinct keys in it. 
      Each key has a room name on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.<br><br>
      
      Given a dictionary of rooms where `rooms[name]` is the list of keys that you can obtain if you visited room `name`, return `True` if you can visit all the rooms, or `False` otherwise.
    max_time: 10
    difficulty: 4.5
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(1)"
        hidden: true
      - name: "names"
        increment: "lambda **kwargs: [fake.safe_color_name().title() for _ in range(kwargs['x'] + 1)]"
        default: "list(['Red', 'Green', 'Blue'])"
        hidden: true
      - name: "unlocked"
        description: "The name of the only unlocked room (to start with)."
        increment: "lambda **kwargs: kwargs['names'][random.randint(0, kwargs['x'])]"
        default: "str('Red')"
      - name: "rooms"
        description: "The dictionary of all rooms and keys."
        increment: "lambda **kwargs: {
                      name: list(set([kwargs['names'][random.randint(0, kwargs['x'])] for x in range(random.randint(0, int(kwargs['x'] ** 0.5 + 2)))]) - {name})
                      for name in kwargs['names']
                    }"
        default: "dict({'Red': ['Green'], 'Blue': ['Red', 'Green'], 'Green': ['Blue']})"

  - function_name: "complementary_dna"
    description: |
      Create a function that converts a sequence of nucleotides (*Adenine* `A`, *Cytosine* `C`, *Thymine* `T`, *Guanine* `G`) contained in an input vector of indefinite length into its complementary sequence (`Adenine --> Thymine`, `Thymine --> Adenine`, `Cytosine --> Guanine`, `Guanine --> Cytosine`).<br>
      
      The function returns a list of characters with the converted sequence.
    max_time: 10
    difficulty: 1.0
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(0)"
        hidden: true
      - name: "sequence"
        description: "The input list containing the nucleotide sequence as a list of characters."
        increment: "lambda **kwargs: [random.choice(['A', 'T', 'C', 'G']) for _ in range(kwargs['x'])]"
        default: "list(['A','A','C','G','T'])"

  - function_name: "prime_factors"
    description: |
      Create a function that decomposes a `number` into its prime factors.<br>
      The function returns a list with all prime factors of the input `number` in ascending order.
    max_time: 10
    difficulty: 2.5
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(0)"
        hidden: true
      - name: "number"
        description: "The number to be decomposed into prime factors."
        increment: "lambda **kwargs: kwargs['number'] + random.randint(1, int(kwargs['x'] ** 0.5))"
        default: "int(1)"
        example: "int(30)"

  - function_name: "partitioning_line"
    description: |
      Create a function that given two points `start` and `end` and a list of points to partition (`points`) returns a list of all points that are on or above the line passing through `start` and `end` (on a cartesian plane).<br>
      The function will return points that lie on or above the line and **not** return points that lie underneath the line.
    max_time: 10
    difficulty: 3.0
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(0)"
        hidden: true
      - name: "start"
        description: "The start point of the line as a list of two coordinates `[x, y]`."
        increment: "lambda **kwargs: [random.randint(0, 10), random.randint(0, 10)]"
        default: "list([0, 0])"
      - name: "end"
        description: "The end point of the line as a list of two coordinates `[x, y]`."
        increment: "lambda **kwargs: [random.randint(0, 10), random.randint(0, 10)]"
        default: "list([10, 10])"
      - name: "points"
        description: "The list of points on the cartesian plane to partition as a list of lists of two coordinates `[x, y]`."
        increment: "lambda **kwargs: [[random.randint(-kwargs['x']-5, kwargs['x']+5), random.randint(-kwargs['x']-5, kwargs['x']+5)] for _ in range(int(kwargs['x'] ** 0.8))]"
        default: "list([[1, 2], [3, 1], [5, 5]])"

  - function_name: "tartaglia_triangle"
    description: |
      Given an input number `n`, return a list of lists containing the numbers of Tartaglia's Triangle up to the `n`th row.
    max_time: 100
    difficulty: 3.0
    args:
      - name: "n"
        description: "The number of rows in Tartaglia's Triangle to generate."
        increment: "lambda x: x + 1"
        default: "int(1)"
        example: "int(5)"

  - function_name: "missing_triangle"
    description: |
      Print a right-angled triangle with given two sides, calculating the missing third side.<br>
      The sides are provided in a dictionary where two of the following are always present:
      * `cathetus1`: The vertical cathethus of the triangle
      * `cathetus2`: The horizontal cathetus of the triangle
      * `hypotenuse`: The hypothenuse of the right-angled triangle
    max_time: 10
    difficulty: 3.5
    args:
      - name: "size"
        increment: "lambda x: x + 1"
        default: "int(3)"
        hidden: true
      - name: "hypothenuse"
        increment: "lambda **kwargs:  random.randint(kwargs['size'] // 2, kwargs['size'])"
        default: "int(5)"
        hidden: true
      - name: "sides"
        description: "A dictionary containing two sides of the triangle."
        increment: "lambda **kwargs: {'cathetus1': random.randint(1, kwargs['hypothenuse'] - 1), 'hypotenuse': kwargs['hypothenuse']} if random.random() < 0.5 else {'cathetus2': random.randint(1, kwargs['hypothenuse'] // 2), 'hypotenuse': kwargs['hypothenuse']}"
        default: "dict({'cathetus1': 3, 'hypotenuse': 5})"

  - function_name: "machine"
    description: |
      Process a list of commands to print characters, where:
      * `0` prints `.`
      * `1` prints `#`
      * `2` prints a newline.
    max_time: 10
    difficulty: 1.0
    args:
      - name: "x"
        increment: "lambda x: x + random.randint(1, 3)"
        default: "int(1)"
        hidden: true
      - name: "commands"
        description: "A list of integer commands consisting of `0`s, `1`s and `2`s"
        increment: "lambda **kwargs: [random.randint(0, 2) for _ in range(kwargs['x'])] + [2]"
        default: "list([1, 0, 2, 0, 1, 1, 2])"

  - function_name: "smallest_city"
    description: |
      Given a list of `City` objects, return the name of the city with the smallest population.
    max_time: 5
    difficulty: 1.5
    include:
      - "City"
    args:
      - name: "x"
        increment: "lambda x: x + random.randint(0, 2)"
        default: "int(1)"
        hidden: true
      - name: "cities"
        description: "A list of City objects."
        increment: "lambda **kwargs: [City(name=fake.city(), pop=random.randint(1000, 1000000)) for _ in range(kwargs['x'])]"
        default: "list([City(name='New York', pop=1000000), City(name='Los Angeles', pop=500000), City(name='Chicago', pop=250000)])"

  - function_name: "total_num_pages"
    description: |
      Given a list of `Book` objects, return the total number of pages across all books.
    max_time: 5
    difficulty: 1.0
    include:
      - "Book"
    args:
      - name: "x"
        increment: "lambda x: x + random.randint(0, 2)"
        default: "int(1)"
        hidden: true
      - name: "books"
        description: "A list of Book objects."
        increment: "lambda **kwargs: [Book(title=fake.sentence(3), pages=random.randint(100, 1000)) for _ in range(kwargs['x'])]"
        default: "list([Book(title='The Great Gatsby', pages=200), Book(title='The Catcher in the Rye', pages=300), Book(title='To Kill a Mockingbird', pages=400)])"

  - function_name: "park_cars"
    description: |
      Given a list of `Car` objects (`garage`) and a list of license plates, the `park_cars` function should return the number of cars with the matching license plates that are not parked.
    max_time: 5
    difficulty: 2.0
    include:
      - "Car"
    args:
      - name: "x"
        increment: "lambda x: x + random.randint(0, 2)"
        default: "int(1)"
        hidden: true
      - name: "l"
        increment: "lambda **kwargs: list({fake.license_plate() for _ in range(kwargs['x'])})"
        default: "list(['ABC123', 'DEF456', 'GHI789'])"
        hidden: true
      - name: "m"
        increment: "lambda **kwargs: [*kwargs['l']]"
        default: "list(['ABC123', 'DEF456', 'GHI789'])"
        hidden: true
      - name: "garage"
        description: "A list of Car objects."
        increment: "lambda **kwargs: [Car(license_plate=kwargs['l'].pop(), is_parked=random.choice([True, False])) for _ in range(len(kwargs['l']))]"
        default: "list([Car(license_plate='ABC123', is_parked=True), Car(license_plate='DEF456', is_parked=False), Car(license_plate='GHI789', is_parked=False)])"
      - name: "license_plates"
        description: "A list of license plates."
        increment: "lambda **kwargs: list({random.choice(kwargs['m']) for _ in range(kwargs['x'])})"
        default: "list(['ABC123', 'GHI789'])"

  - function_name: "calculate_gpa"
    description: |
      Given a list of `Student` objects and a student's name, calculate their GPA (assuming each grade is a numerical value), and return the GPA.
    max_time: 5
    difficulty: 2.0
    include:
      - "Student"
    args:
      - name: "x"
        increment: "lambda x: x + random.randint(0, 2)"
        default: "int(1)"
        hidden: true
      - name: "n"
        increment: "lambda **kwargs: list({fake.name() for _ in range(kwargs['x'])})"
        default: "list(['Alice', 'Bob', 'Charlie'])"
        hidden: true
      - name: "m"
        increment: "lambda **kwargs: [*kwargs['n']]"
        default: "list(['Alice', 'Bob', 'Charlie'])"
        hidden: true
      - name: "students"
        description: "A list of Student objects."
        increment: "lambda **kwargs: [Student(name=kwargs['n'].pop(), grades=[random.randint(2, 10) for _ in range(random.randint(1, 5))]) for _ in range(len(kwargs['n']))]"
        default: "list([Student(name='Alice', grades=[9, 8, 7]), Student(name='Bob', grades=[8, 7, 6]), Student(name='Charlie', grades=[7, 6, 5])])"
      - name: "name"
        description: "The name of the student."
        increment: "lambda **kwargs: random.choice(kwargs['m'])"
        default: "str('Alice')"