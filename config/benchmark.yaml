reference_module: "benchmarks.reference"

user_modules:
  - "benchmarks.team01"
  - "benchmarks.team02"
  - "benchmarks.team03"

benchmarks:
  - function_name: "square"
    description: Print a square of a given size.
    max_time: 100000
    difficulty: 1.5
    args:
      - name: "size"
        description: "The size of the square's sides."
        increment: "lambda x: x + 1"
        default: "int(1)"
        example: "int(4)"

  - function_name: "triangle"
    description: Print a right-angled triangle with stars.
    max_time: 100000
    difficulty: 2.0
    args:
      - name: "size"
        description: "The height of the triangle."
        increment: "lambda x: x + 1"
        default: "int(1)"
        example: "int(4)"

  - function_name: "rhombus"
    description: Print a rhombus pattern.
    max_time: 100000
    difficulty: 2.5
    args:
      - name: "size"
        description: "The size of the rhombus."
        increment: "lambda x: x + 1"
        default: "int(1)"
        example: "int(5)"

  - function_name: "running_sum"
    description: Return the (cumulative) running sum of a list.
    max_time: 50000
    difficulty: 2.0
    args:
      - name: "size"
        increment: "lambda x: x + 1"
        default: "int(1)"
        hidden: true
      - name: "nums"
        description: "The list of integers for calculating the running sum."
        increment: "lambda **kwargs: [random.randint(0, 100) for _ in range(kwargs['size'])]"
        default: "list([2,5,3,1])"

  - function_name: "histogram"
    description: Print a histogram from a list of numbers.
    max_time: 50000
    difficulty: 2.5
    args:
      - name: "size"
        increment: "lambda x: x + 1"
        default: "int(1)"
        hidden: true
      - name: "nums"
        description: "The list of numbers for generating a histogram."
        increment: "lambda **kwargs: [random.randint(0, 10) for _ in range(kwargs['size'])]"
        default: "list([4,1,2])"

  - function_name: "scatter"
    description: Print a scatter plot of points of a given size.
    max_time: 50000
    difficulty: 3.0
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(3)"
        hidden: true
      - name: "size"
        description: "The size of the scatter plot."
        increment: "lambda **kwargs: int(kwargs['x'] ** 0.65)"
        default: "int(4)"
      - name: "points"
        description: "The list of points as tuples for the scatter plot."
        increment: "lambda **kwargs: [[random.randint(1, kwargs['size']), random.randint(1, kwargs['size'])] for _ in range(random.randint(1, kwargs['size'] + 1))]"
        default: "list([[2,2],[1,3],[4,1]])"

  - function_name: "count_pairs"
    description: Given a list of pairs `nums`, return the count of pairs of numbers that differ by a specific amount (`k`).
    max_time: 50000
    difficulty: 2.5
    args:
      - name: "size"
        increment: "lambda x: x + 1"
        default: "int(1)"
        hidden: true
      - name: "nums"
        description: "The list of numbers to count pairs from."
        increment: "lambda **kwargs: [random.randint(0, kwargs['size'] // 2) for _ in range(kwargs['size'])]"
        default: "list([1,2,2,1])"
      - name: "k"
        description: "The difference value for counting pairs."
        increment: "lambda **kwargs: random.randint(1, kwargs['size'] // 2)"
        default: "int(1)"

  - function_name: "dividing_numbers"
    description: Return a list of all self-dividing numbers in a range.
    max_time: 50000
    difficulty: 2.5
    args:
      - name: "size"
        increment: "lambda x: x + 1"
        default: "int(10)"
        hidden: true
      - name: "left"
        description: "The left boundary of the range."
        increment: "lambda **kwargs: random.randint(0, kwargs['size'] // 2)"
        default: "int(0)"
      - name: "right"
        description: "The right boundary of the range."
        increment: "lambda **kwargs: random.randint(kwargs['size'] // 2, kwargs['size'])"
        default: "int(10)"

  - function_name: "generate_trajectory"
    description: Print the trajectory of a projectile which is launched with a given `angle` and `velocity`.
    max_time: 50000
    difficulty: 4.0
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(25)"
        hidden: true
      - name: "velocity"
        description: "The initial velocity of the projectile."
        increment: "lambda **kwargs: int(kwargs['x'] * (0.1 + random.random()))"
        default: "int(15)"
      - name: "angle"
        description: "The angle of projection."
        increment: "lambda angle: int(45 + (random.random() - 0.5) * 45)"
        default: "int(45)"
      - name: "size"
        description: "The size of the simulation area."
        increment: "lambda **kwargs: [random.randint(kwargs['x'], int(kwargs['x'] * 1.5)), random.randint(kwargs['x'] // 3, kwargs['x'] // 1.5)]"
        default: "list([25, 8])"

  - function_name: "sort_by_height"
    description: |
      Return a list of people sorted by corresponding heights.
      Tallest person first.
    max_time: 10000
    difficulty: 2.0
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(1)"
        hidden: true
      - name: "names"
        description: "The list of names."
        increment: "lambda **kwargs: list(set([fake.first_name() for _ in range(kwargs['x'])]))"
        default: "list(['Alice', 'Bob', 'Charlie'])"
      - name: "heights"
        description: "The list of corresponding heights."
        increment: "lambda **kwargs: [random.randint(150, 200) for _ in range(len(kwargs['names']))]"
        default: "list([165, 180, 175])"

  - function_name: "best_student"
    description: Given a dictionary of students and their grades, return the name of the student with the highest average grade.
    max_time: 15000
    difficulty: 3.0
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(1)"
        hidden: true
      - name: "offsets"
        increment: "lambda **kwargs: [random.randint(2, 7) for _ in range(kwargs['x'])]"
        default: "list([4, 5, 4])"
        hidden: true
      - name: "gradebook"
        description: "The dictionary containing student names and their grades."
        increment: "lambda **kwargs: {
                      fake.first_name(): [
                        round(random.uniform(0, 3) + kwargs['offsets'][idx], 1) for _ in range(random.randint(1, int(kwargs['x'] ** 1.15 // 3 + 1)))
                      ] for idx in range(kwargs['x'])
                    }"
        default: "dict({'Alice': [8, 7.5, 8.8],'Bob': [8, 9],'Charlie': [6.2, 7.5]})"

  - function_name: "can_visit_all_rooms"
    description: |
      You are given a dictionary of room names and all the rooms are locked except for the `unlocked` room in the dictionary.
      Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.<br><br>
      
      When you visit a room, you may find a list of distinct keys in it. 
      Each key has a room name on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.<br><br>
      
      Given a dictionary of rooms where `rooms[name]` is the list of keys that you can obtain if you visited room `name`, return `True` if you can visit all the rooms, or `False` otherwise.
    max_time: 5000
    difficulty: 4.5
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(1)"
        hidden: true
      - name: "names"
        increment: "lambda **kwargs: [fake.safe_color_name().title() for _ in range(kwargs['x'] + 1)]"
        default: "list(['Red', 'Green', 'Blue'])"
        hidden: true
      - name: "unlocked"
        description: "The name of the only unlocked room (to start with)."
        increment: "lambda **kwargs: kwargs['names'][random.randint(0, kwargs['x'])]"
        default: "str('Red')"
      - name: "rooms"
        description: "The dictionary of all rooms and keys."
        increment: "lambda **kwargs: {
                      name: list(set([kwargs['names'][random.randint(0, kwargs['x'])] for x in range(random.randint(0, int(kwargs['x'] ** 0.5 + 2)))]) - {name})
                      for name in kwargs['names']
                    }"
        default: "dict({'Red': ['Green'], 'Blue': ['Red', 'Green'], 'Green': ['Blue']})"

  - function_name: "jobs_counter"
    description: Return a dictionary with the count of occurrences for each job in a list.
    max_time: 10000
    difficulty: 2.0
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(3)"
        hidden: true
      - name: "elems"
        increment: "lambda **kwargs: [fake.job() for _ in range(int(kwargs['x'] ** 0.5))]"
        default: "list(['artist', 'doctor', 'professor'])"
        hidden: true
      - name: "jobs"
        description: "The list of jobs."
        increment: "lambda **kwargs: [
                      kwargs['elems'][int(random.randint(0, len(kwargs['elems']) - 1))] for _ in range(int(kwargs['x'] ** 1.15))
                    ]"
        default: "list(['doctor', 'professor', 'artist', 'professor', 'professor', 'artist'])"

  - function_name: "biggest_pair"
    description: |
      Create a function that given two numbers returns the largest number of the two.
    max_time: 1000
    difficulty: 1.5
    args:
      - name: "x"
        increment: "lambda **kwargs: random.randint(-100, 100)"
        description: "The first number."
        default: "int(12)"
      - name: "y"
        increment: "lambda **kwargs: random.randint(-100, 100)"
        description: "The second number."
        default: "int(4)"

  - function_name: "smallest_number"
    description: |
      Create a function that given three numbers returns the smallest number of the three.
    max_time: 2000
    difficulty: 0.5
    args:
      - name: "x"
        increment: "lambda **kwargs: random.randint(-100, 100)"
        description: "The first number."
        default: "int(12)"
      - name: "y"
        increment: "lambda **kwargs: random.randint(-100, 100)"
        description: "The second number."
        default: "int(4)"
      - name: "z"
        increment: "lambda **kwargs: random.randint(-100, 100)"
        description: "The third number."
        default: "int(87)"

  - function_name: "complementary_dna"
    description: |
      Create a function that converts a sequence of nucleotides (*Adenine* `A`, *Cytosine* `C`, *Thymine* `T`, *Guanine* `G`) contained in an input vector of indefinite length into its complementary sequence (`Adenine --> Thymine`, `Thymine --> Adenine`, `Cytosine --> Guanine`, `Guanine --> Cytosine`).<br>
      
      The function returns a list of characters with the converted sequence.
    max_time: 10000
    difficulty: 1.5
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(0)"
        hidden: true
      - name: "sequence"
        description: "The input list containing the nucleotide sequence as a list of characters."
        increment: "lambda **kwargs: [random.choice(['A', 'T', 'C', 'G']) for _ in range(kwargs['x'])]"
        default: "list(['A','A','C','G','T'])"

  - function_name: "calculate_discount"
    description: |
      Create a function that calculates the final price after applying a discount percentage to all the items in the `shopping` list. The function should return the final price which is the sum of all the discounted items in `shopping`.
    max_time: 3000
    difficulty: 2.5
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(0)"
        hidden: true
      - name: "shopping"
        description: "The list of items to apply the discount to."
        increment: "lambda **kwargs: [random.randint(1, 1000) / 10 for _ in range(kwargs['x'])]"
        default: "list([10.5, 8.7, 30])"
      - name: "discount"
        description: "The discount percentage to apply to all items."
        increment: "lambda **kwargs: random.randint(1, 19) * 5"
        default: "int(20)"

  - function_name: "even_numbers"
    description: |
      Create a function that given a list of integers, returns a new list containing only the even numbers from the original list.
    max_time: 4000
    difficulty: 1.5
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(0)"
        hidden: true
      - name: "numbers"
        description: "The list of integers to filter."
        increment: "lambda **kwargs: [random.randint(1, 100) for _ in range(kwargs['x'])]"
        default: "list([1, 2, 3, 4, 5])"

  - function_name: "odd_numbers"
    description: |
      Create a function that given a list of integers, returns a new list containing only the odd numbers from the original list.
    max_time: 4000
    difficulty: 2.5
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(0)"
        hidden: true
      - name: "numbers"
        description: "The list of integers to filter."
        increment: "lambda **kwargs: [random.randint(1, 100) for _ in range(kwargs['x'])]"
        default: "list([1, 2, 3, 4, 5])"

  - function_name: "add_items"
    description: |
      Create a function that given a list of integers, and two new items to add, adds the two new items to the list.
    max_time: 4000
    difficulty: 2.0
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(0)"
        hidden: true
      - name: "numbers"
        description: "The list of integers to filter."
        increment: "lambda **kwargs: [random.randint(1, 100) for _ in range(kwargs['x'])]"
        default: "list([1, 2, 3, 4, 5])"
      - name: "x"
        increment: "lambda **kwargs: random.randint(-100, 100)"
        description: "The first number."
        default: "int(12)"
      - name: "y"
        increment: "lambda **kwargs: random.randint(-100, 100)"
        description: "The second number."
        default: "int(4)"

  - function_name: "city_life"
    description: |
      Create a function that given two sets of people, the set of people that live in `turin` and the set of people that live in `milan`, returns the `set` of people that live both in `turin` and `milan`.
    max_time: 2000
    difficulty: 1.0
    args:
      - name: "size"
        increment: "lambda x: x + 1"
        default: "int(4)"
        hidden: true
      - name: "people"
        increment: "lambda **kwargs: list({fake.first_name() for _ in range(kwargs['size'] * 2)})"
        default: "set(['Adam', 'Charlie', 'Roger', 'Zethus'])"
        hidden: true
      - name: "turin"
        description: "The set of people that live in Turin."
        increment: "lambda **kwargs: {random.choice(kwargs['people'])  for _ in range(kwargs['size'])}"
        default: "set(['Adam', 'Roger', 'Zethus'])"
      - name: "milan"
        description: "The set of people that live in Milan."
        increment: "lambda **kwargs: {random.choice(kwargs['people'])  for _ in range(kwargs['size'])}"
        default: "set(['Charlie', 'Roger', 'Zethus'])"

  - function_name: "prime_factors"
    description: |
      Create a function that decomposes a `number` into its prime factors.<br>
      The function returns a list with all prime factors of the input `number` in ascending order.
    max_time: 10000
    difficulty: 2.5
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(0)"
        hidden: true
      - name: "number"
        description: "The number to be decomposed into prime factors."
        increment: "lambda **kwargs: kwargs['number'] + random.randint(1, int(kwargs['x'] ** 0.5))"
        default: "int(1)"
        example: "int(30)"

  - function_name: "partitioning_line"
    description: |
      Create a function that given two points `start` and `end` and a list of points to partition (`points`) returns a list of all points that are on or above the line passing through `start` and `end` (on a cartesian plane).<br>
      The function will return points that lie on or above the line and **not** return points that lie underneath the line.
    max_time: 10000
    difficulty: 3.0
    args:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(0)"
        hidden: true
      - name: "start"
        description: "The start point of the line as a list of two coordinates `[x, y]`."
        increment: "lambda **kwargs: [random.randint(0, 10), random.randint(0, 10)]"
        default: "list([0, 0])"
      - name: "end"
        description: "The end point of the line as a list of two coordinates `[x, y]`."
        increment: "lambda **kwargs: [random.randint(0, 10), random.randint(0, 10)]"
        default: "list([10, 10])"
      - name: "points"
        description: "The list of points on the cartesian plane to partition as a list of lists of two coordinates `[x, y]`."
        increment: "lambda **kwargs: [[random.randint(-kwargs['x']-5, kwargs['x']+5), random.randint(-kwargs['x']-5, kwargs['x']+5)] for _ in range(int(kwargs['x'] ** 0.8))]"
        default: "list([[1, 2], [3, 1], [5, 5]])"

  - function_name: "pascal_triangle"
    description: |
      Given an input number `n`, return a list of lists containing the numbers of Pascal's Triangle up to the `n`th row.
    max_time: 100000
    difficulty: 3.5
    args:
      - name: "n"
        description: "The number of rows in Pascal's Triangle to generate."
        increment: "lambda x: x + 1"
        default: "int(1)"
        example: "int(5)"

  - function_name: "missing_triangle"
    description: |
      Print a right-angled triangle with given two sides, calculating the missing third side.<br>
      The sides are provided in a dictionary where two of the following are always present:
      * `cathetus1`: The vertical cathethus of the triangle
      * `cathetus2`: The horizontal cathetus of the triangle
      * `hypotenuse`: The hypothenuse of the right-angled triangle
    max_time: 10000
    difficulty: 3.5
    args:
      - name: "size"
        increment: "lambda x: x + 1"
        default: "int(3)"
        hidden: true
      - name: "hypothenuse"
        increment: "lambda **kwargs:  random.randint(kwargs['size'] // 2, kwargs['size'])"
        default: "int(5)"
        hidden: true
      - name: "sides"
        description: "A dictionary containing two sides of the triangle."
        increment: "lambda **kwargs: {'cathetus1': random.randint(1, kwargs['hypothenuse'] - 1), 'hypotenuse': kwargs['hypothenuse']} if random.random() < 0.5 else {'cathetus2': random.randint(1, kwargs['hypothenuse'] // 2), 'hypotenuse': kwargs['hypothenuse']}"
        default: "dict({'cathetus1': 3, 'hypotenuse': 5})"

  - function_name: "machine"
    description: |
      Process a list of commands to print characters, where:
      * `0` prints `.`
      * `1` prints `#`
      * `2` prints a newline.
    max_time: 10000
    difficulty: 1.5
    args:
      - name: "x"
        increment: "lambda x: x + random.randint(1, 3)"
        default: "int(1)"
        hidden: true
      - name: "commands"
        description: "A list of integer commands consisting of `0`s, `1`s and `2`s"
        increment: "lambda **kwargs: [random.randint(0, 2) for _ in range(kwargs['x'])] + [2]"
        default: "list([1, 0, 2, 0, 1, 1, 2])"

  - function_name: "smallest_city"
    description: |
      Given a list of `City` objects, return the instance of the `City` object with the smallest population.
    max_time: 2000
    difficulty: 1.5
    include:
      - "City"
    args:
      - name: "x"
        increment: "lambda x: x + random.randint(0, 2)"
        default: "int(1)"
        hidden: true
      - name: "cities"
        description: "A list of City objects."
        increment: "lambda **kwargs: [City(name=fake.city(), population=random.randint(1000, 1000000)) for _ in range(kwargs['x'])]"
        default: "list([City(name='New York', population=1000000), City(name='Los Angeles', population=500000), City(name='Chicago', population=250000)])"

  - function_name: "total_height"
    description: |
      Given two people, find the sum of their heights.
    max_time: 500
    difficulty: 0.5
    include:
      - "Person"
    args:
      - name: "person_a"
        increment: "lambda **kwargs: Person(name=fake.first_name(), height=random.randint(150, 210))"
        default: "Person(name='Carlo', height=180)"
      - name: "person_b"
        increment: "lambda **kwargs: Person(name=fake.first_name(), height=random.randint(150, 210))"
        default: "Person(name='Paola', height=165)"

  - function_name: "total_num_pages"
    description: |
      Given a list of `Book` objects, return the total number of pages across all books.
    max_time: 2000
    difficulty: 1.0
    include:
      - "Book"
    args:
      - name: "x"
        increment: "lambda x: x + random.randint(0, 2)"
        default: "int(1)"
        hidden: true
      - name: "books"
        description: "A list of Book objects."
        increment: "lambda **kwargs: [Book(title=fake.sentence(3, variable_nb_words=False), pages=random.randint(100, 1000)) for _ in range(kwargs['x'])]"
        default: "list([Book(title='The Great Gatsby', pages=200), Book(title='The Catcher in the Rye', pages=300), Book(title='To Kill a Mockingbird', pages=400)])"

  - function_name: "park_cars"
    description: |
      Given a list of `Car` objects (`garage`) and a list of license plates, the `park_cars` function should return the number of cars with the matching license plates that are not parked.
    max_time: 15000
    difficulty: 1.5
    include:
      - "Car"
    args:
      - name: "x"
        increment: "lambda x: x + random.randint(0, 2)"
        default: "int(1)"
        hidden: true
      - name: "l"
        increment: "lambda **kwargs: list({fake.license_plate() for _ in range(kwargs['x'])})"
        default: "list(['ABC123', 'DEF456', 'GHI789'])"
        hidden: true
      - name: "m"
        increment: "lambda **kwargs: [*kwargs['l']]"
        default: "list(['ABC123', 'DEF456', 'GHI789'])"
        hidden: true
      - name: "garage"
        description: "A list of Car objects."
        increment: "lambda **kwargs: [Car(license_plate=kwargs['l'].pop(), is_parked=random.choice([True, False])) for _ in range(len(kwargs['l']))]"
        default: "list([Car(license_plate='ABC123', is_parked=True), Car(license_plate='DEF456', is_parked=False), Car(license_plate='GHI789', is_parked=False)])"
      - name: "license_plates"
        description: "A list of license plates."
        increment: "lambda **kwargs: list({random.choice(kwargs['m']) for _ in range(kwargs['x'])})"
        default: "list(['ABC123', 'GHI789'])"

  - function_name: "calculate_gpa"
    description: |
      Given a list of `Student` objects and a student's `name`, calculate their GPA (assuming each grade is a numerical value), and return the GPA.
      GPA stands for "Grade Point Average", that is the arithmetic average (out of `10`) of a student's `grades`.
    max_time: 1000
    difficulty: 2.5
    include:
      - "Student"
    args:
      - name: "x"
        increment: "lambda x: x + random.randint(0, 2)"
        default: "int(1)"
        hidden: true
      - name: "n"
        increment: "lambda **kwargs: list({fake.first_name() for _ in range(kwargs['x'])})"
        default: "list(['Alice', 'Bob', 'Charlie'])"
        hidden: true
      - name: "m"
        increment: "lambda **kwargs: [*kwargs['n']]"
        default: "list(['Alice', 'Bob', 'Charlie'])"
        hidden: true
      - name: "students"
        description: "A list of Student objects."
        increment: "lambda **kwargs: [Student(name=kwargs['n'].pop(), grades=[random.randint(2, 10) for _ in range(random.randint(1, 5))]) for _ in range(len(kwargs['n']))]"
        default: "list([Student(name='Alice', grades=[9, 8, 7]), Student(name='Bob', grades=[8, 7, 6]), Student(name='Charlie', grades=[7, 6, 5])])"
      - name: "name"
        description: "The name of the student."
        increment: "lambda **kwargs: random.choice(kwargs['m'])"
        default: "str('Alice')"

  - class_name: "Coordinate"
    description: |
      Within a class `Coordinate` representing a point in a 2D plane.
      Implement a `distance` method to calculate the distance from another `Coordinate`.
    max_time: 2000
    difficulty: 1.5
    init:
      - name: "size"
        increment: "lambda x: x + 1"
        default: "int(3)"
        hidden: true
      - name: "x"
        description: "The x-axis of the coordinate."
        increment: "lambda **kwargs: random.randint(-kwargs['size'], kwargs['size'])"
        default: "int(4)"
      - name: "y"
        description: "The y-axis of the coordinate."
        increment: "lambda **kwargs: random.randint(-kwargs['size'], kwargs['size'])"
        default: "int(2)"
    methods:
      - method_name: "distance"
        description: "Calculate the distance from another Coordinate."
        args:
          - name: "other"
            description: "The other Coordinate to calculate the distance from."
            increment: "lambda **kwargs: Coordinate(x=random.randint(-kwargs['size'], kwargs['size']), y=random.randint(-kwargs['size'], kwargs['size']))"
            default: "Coordinate(x=1, y=1)"
    evaluation:
      increment: "lambda **kwargs: list(['distance'])"
      default: "list(['distance'])"

  - class_name: "Warehouse"
    description: |
      You are given a class `Warehouse` representing a warehouse with number of products.
      You must implement the three methods `add_products`, `remove_products` and `get_products` to manage the warehouse operations.
    max_time: 20000
    difficulty: 2.0
    init:
      - name: "size"
        increment: "lambda x: x + 1"
        default: "int(1)"
        hidden: true
      - name: "products"
        description: "The number of products in the warehouse."
        increment: "lambda **kwargs: random.randint(0, kwargs['size'])"
        default: "int(4)"
    methods:
      - method_name: "add_products"
        description: "Add a given amount of products to the warehouse."
        args:
          - name: "amount"
            description: "The amount of products to add."
            increment: "lambda **kwargs: random.randint(0, kwargs['size'])"
            default: "int(45)"
      - method_name: "remove_products"
        description: |
          Remove a given amount of products from the warehouse.
          **NOTE**: The amount of products cannot go negative.
        args:
          - name: "amount"
            description: "The amount of products to remove."
            increment: "lambda **kwargs: random.randint(0, kwargs['size'])"
            default: "int(18)"
      - method_name: "get_products"
        description: "Get the number of products in the warehouse."
        args: [ ]
    evaluation:
      increment: "lambda **kwargs: [random.choice(['add_products', 'remove_products']) for _ in range(kwargs['size'] // 2)] + ['get_products']"
      default: "list(['add_products', 'remove_products', 'get_products'])"

  - class_name: "BookStore"
    description: |
      You are given a class `BookStore` representing a bookstore with a list of `Books`.
      You must implement the two methods `add_book` and `get_num_copies` to manage the bookstore operations.
    max_time: 40000
    difficulty: 2.0
    include:
      - "Book"
    init:
      - name: "size"
        increment: "lambda x: x + 1"
        default: "int(1)"
        hidden: true
      - name: "all_books"
        description: "The universe all all books."
        increment: "lambda **kwargs: [Book(title=fake.sentence(3, variable_nb_words=False), pages=random.randint(100, 1000)) for _ in range(kwargs['size'])]"
        default: "list([Book(title='The Great Gatsby', pages=200), Book(title='The Catcher in the Rye', pages=300), Book(title='To Kill a Mockingbird', pages=400)])"
        hidden: true
      - name: "books"
        description: "The list of books in the bookstore."
        increment: "lambda **kwargs: kwargs['all_books'][:kwargs['size'] // 2]"
        default: "list([Book(title='The Great Gatsby', pages=200), Book(title='The Catcher in the Rye', pages=300)])"
    methods:
      - method_name: "add_book"
        description: "Add a given Book object to the bookstore."
        args:
          - name: "book"
            description: "The Book object to add to the bookstore."
            increment: "lambda **kwargs: random.choice(kwargs['all_books'])"
            default: "Book(title='To Kill a Mockingbird', pages=400)"
      - method_name: "get_num_copies"
        description: |
          Get the number of copies of the specified Book stored in the bookstore. 
          **NOTE**: The `Book` object may not be in the bookstore.
          **NOTE 2**: There may me duplicates of the same `Book`.
        args:
          - name: "book"
            description: "The Book object to get the number of copies of. "
            increment: "lambda **kwargs: random.choice(kwargs['all_books'])"
            default: "Book(title='The Great Gatsby', pages=200)"
    evaluation:
      increment: "lambda **kwargs: ['add_book'] * (int(kwargs['size'] ** 1.15)) + ['get_num_copies']"
      default: "list(['add_book', 'get_num_copies'])"

  - class_name: "SimpleCar"
    description: |
      You are given a class `SimpleCar` representing on a 2D plane.
      The car starts at a given `position` and can move in four directions: `up`, `down`, `left` and `right`.
      There are a list of `Obstacles` on the plane that the car cannot pass through.
      If the car tries to move through an obstacle, it will instead stay in its current position.
    max_time: 50000
    difficulty: 4.0
    include:
      - "Position"
      - "Obstacle"
    init:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(4)"
        hidden: true
      - name: "size"
        increment: "lambda **kwargs: int(kwargs['x'] ** 0.5)"
        default: "int(2)"
        hidden: true
      - name: "position"
        description: "The initial position of the car."
        increment: "lambda **kwargs: Position(x=random.randint(-kwargs['size']//2, kwargs['size']//2), y=random.randint(-kwargs['size']//2, kwargs['size']//2))"
        default: "Position(x=0, y=0)"
      - name: "obstacles"
        description: "The list of obstacles on the plane."
        increment: "lambda **kwargs: [Obstacle(position=Position(x=random.randint(-kwargs['size'], kwargs['size']), y=random.randint(-kwargs['size'], kwargs['size']))) for _ in range(int(kwargs['size'] ** 1.5))]"
        default: "list([Obstacle(position=Position(x=1, y=1)), Obstacle(position=Position(x=-1, y=0))])"
    methods:
      - method_name: "move_up"
        description: "Move the car up (y-axis) by one unit."
        args: [ ]
      - method_name: "move_down"
        description: "Move the car down (y-axis) by one unit."
        args: [ ]
      - method_name: "move_left"
        description: "Move the car left (x-axis) by one unit."
        args: [ ]
      - method_name: "move_right"
        description: "Move the car right (x-axis) by one unit."
        args: [ ]
      - method_name: "get_position"
        description: "Get the current position of the car."
        args: [ ]
    evaluation:
      increment: "lambda **kwargs: [random.choice(['move_up', 'move_down', 'move_left', 'move_right']) for _ in range(kwargs['size'] * 2)] + ['get_position']"
      default: "list(['move_up', 'move_right', 'move_left', 'move_down', 'get_position'])"

  - class_name: "Cipher"
    description: |
      You are given a class `Cipher` representing a cipher that can encrypt and decrypt a given message.
      The cipher is initialized with a given `key` which is a list of integers.
      The cipher works by shifting each character in the message by the corresponding amount in the key.
      For example, if the key is `2` and the message is `"abc"`, the encrypted message will be `"cde"`.
    max_time: 10000
    difficulty: 4.5
    include:
      - "CIPHER_MAPPING"
    init:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(1)"
        hidden: true
      - name: "key"
        description: "The key to use for the cipher."
        increment: "lambda **kwargs: random.randint(1, 100)"
        default: "2"
      - name: "message"
        description: "The message to encrypt."
        increment: "lambda **kwargs: fake.sentence(int(kwargs['x'] ** 0.5) + 1, variable_nb_words=False).lower()"
        default: "str('the cat is on the table!')"
    methods:
      - method_name: "encrypt"
        description: |
          Encrypt a given message using the cipher.
          **NOTE**: This method is already implemented for you!
        args: [ ]
        hidden: false
      - method_name: "decrypt"
        description: "Decrypt a given message using the cipher."
        args: [ ]
      - method_name: "get_message"
        description: "Return the message currently held by the cypher (encrypted or decrypted)."
        args: [ ]
    evaluation:
      increment: "lambda **kwargs: (['encrypt'] if random.randint(1, 100) < 90 else []) + ['decrypt'] + ['get_message']"
      default: "list(['encrypt', 'decrypt', 'get_message'])"

  - class_name: "Line"
    description: |
      A class representing a line in a two-dimensional space, using the implicit formula `ax + by = c`.
      The class provides functionalities to compare `Lines` and to check if `Points` lie on the `Line`.
      You must implement the `is_parallel`, `intersection` and `contains_point` methods to provide this functionality.
    max_time: 3000
    difficulty: 5.0
    include:
      - "Point"
    init:
      - name: "size"
        increment: "lambda x: x + 1"
        default: "int(4)"
        hidden: true
      - name: "x"
        increment: "lambda **kwargs: int(kwargs['size'] ** 0.5)"
        default: "int(2)"
        hidden: true
      - name: "a"
        description: "The coefficient 'a' in the line equation."
        increment: "lambda **kwargs: random.randint(-kwargs['x'], kwargs['x'])"
        default: "int(1)"
      - name: "b"
        description: "The coefficient 'b' in the line equation."
        increment: "lambda **kwargs: random.randint(-kwargs['x'], kwargs['x'])"
        default: "int(-1)"
      - name: "c"
        description: "The constant 'c' in the line equation."
        increment: "lambda **kwargs: random.randint(-kwargs['x'], kwargs['x'])"
        default: "int(2)"
    methods:
      - method_name: "is_parallel"
        description: |
          Determines if another `Line` object is parallel to this line.
          **NOTE**: Two lines are parallel if their coefficients `a` and `b` are proportional.
        args:
          - name: "other_line"
            description: "Another Line object to compare with."
            increment: "lambda **kwargs: Line(random.randint(-kwargs['x'], kwargs['x']), random.randint(-kwargs['x'], kwargs['x']), random.randint(-kwargs['x'], kwargs['x']))"
            default: "Line(1, -1, 3)"
      - method_name: "intersection"
        description: |
          Calculates the intersection point with another Line object, if one exists.
          **NOTE**: If the lines are parallel, the method should return `None`.
          **NOTE 2**: The intersection point is calculated by solving the system of equations formed by the two lines.
        args:
          - name: "other_line"
            description: "Another Line object to find the intersection with."
            increment: "lambda **kwargs: Line(random.randint(-kwargs['x'], kwargs['x']), random.randint(-kwargs['x'], kwargs['x']), random.randint(-kwargs['x'], kwargs['x']))"
            default: "Line(1, 1, 4)"
      - method_name: "contains_point"
        description: |
          Checks if a given Point (using a Position object for its position) lies on this line.
          **NOTE**: A point lies on a line if it satisfies the implicit equation `ax + by = c`.
        args:
          - name: "point"
            description: "A Point object representing the point to check."
            increment: "lambda **kwargs: random.choice([Point(random.choice([kwargs['a'], kwargs['b']]), random.choice([kwargs['a'], kwargs['c']])), Point(kwargs['a'] and kwargs['c'] / kwargs['a'] or 0, 0), Point(0, kwargs['b'] and kwargs['c'] / kwargs['b'] or 0)])"
            default: "Point(1, 1)"
    evaluation:
      increment: "lambda **kwargs: ['is_parallel', 'intersection', 'contains_point']"
      default: "['is_parallel', 'intersection', 'contains_point']"

  - class_name: "DiceGame"
    description: |
      You are given a class `DiceGame` representing a game of dice.
      The game is initialised with a list of `Player` objects and a single `FairDice` object.
      The game is divided into two phases: 
      1) The `play` phase where each player **in the input order** roll the `dice` and update their scores.
      2) The `get_winner` phase where the winner is determined by the highest score and then all player scores are reset.
      There can be multiple `play` and `get_winner` phases back-to-back.
      In case of a **tie** the winner is the player with the lowest score that comes first in the input order.
    max_time: 200000
    difficulty: 3.5
    include:
      - "FairDice"
      - "Player"
    init:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(4)"
        hidden: true
      - name: "player_names"
        increment: "lambda **kwargs: list({fake.first_name() for _ in range(int(kwargs['x'] ** 0.5))})"
        default: "list(['Alice', 'Bob'])"
        hidden: true
      - name: "players"
        description: "The list of players in the game."
        increment: "lambda **kwargs: [Player(name=name, score=0) for name in kwargs['player_names']]"
        default: "list([Player(name='Alice', score=0), Player(name='Bob', score=0)])"
      - name: "dice"
        description: "The dice used in the game."
        increment: "lambda **kwargs: FairDice(random.randint(1, 6))"
        default: "FairDice(1)"
    methods:
      - method_name: "play"
        description: |
          Play a single round of the game.
          Each player rolls the dice and updates their score.
          **NOTE**: To roll the dice you **MUST** use the `roll_and_update` method defined on `Player` objects.
        args: [ ]
      - method_name: "get_winner"
        description: "Get the name of the winning player of the game."
        args: [ ]
    evaluation:
      increment: "lambda **kwargs: ['play'] + [random.choice(['play', 'play', 'play', 'get_winner']) for _ in range(kwargs['x'] // 3)] + ['get_winner']"
      default: "['play', 'play', 'get_winner']"

  - class_name: "GuessWhoGame"
    description: |
      You are given a class `GuessWhoGame` representing a game of Guess Who.
      The game is initialised with a list of `Candidate` objects and an `answer` (i.e. a single `Candidate` object).
      The game is divided into two phases: 
      1) The `ask` phase where the player asks a question to the game and the game answers with a `True` or `False` value.
      2) The `guess` phase where the player can try to guess if the `answer` is a specific `Candidate`.
      There can be multiple `ask` and `guess` phases back-to-back.
      The player can ask about three different attributes of the `Candidate`: `hair_color`, `eye_color` and `glasses`.
    difficulty: 3.0
    max_time: 20000
    include:
      - "Candidate"
    init:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(4)"
        hidden: true
      - name: "options"
        increment: "lambda **kwargs: list({Candidate(name=fake.first_name(), hair_color=random.choice(['black', 'brown', 'blonde', 'red', 'white', 'gray']), eye_color=random.choice(['blue', 'green', 'brown']), has_glasses=random.choice([True, False])) for _ in range(int(kwargs['x'] ** 0.5))})"
        default: "list([Candidate(name='Bob', hair_color='black', eye_color='blue', has_glasses=True), Candidate(name='Anne', hair_color='red', eye_color='green', has_glasses=False)])"
        hidden: true
      - name: "answer"
        description: "The answer to the game."
        increment: "lambda **kwargs: random.choice(kwargs['options'])"
        default: "Candidate(name='Bob', hair_color='black', eye_color='blue', has_glasses=True)"
      - name: "candidates"
        description: "The list of candidates in the game."
        increment: "lambda **kwargs: kwargs['options']"
        default: "list([Candidate(name='Bob', hair_color='black', eye_color='blue', has_glasses=True), Candidate(name='Anne', hair_color='red', eye_color='green', has_glasses=False)])"
    methods:
      - method_name: "guess"
        description: "Guess if the `answer` is a specific `Candidate`."
        args:
          - name: "candidate"
            description: "The candidate to guess."
            increment: "lambda **kwargs: random.choice(kwargs['options'])"
            default: "Candidate(name='Bob', hair_color='black', eye_color='blue', has_glasses=True)"
      - method_name: "ask_hair_color"
        description: "Ask if the `answer` has a specific hair color."
        args:
          - name: "hair_color"
            description: "The hair color to ask about."
            increment: "lambda **kwargs: random.choice(['black', 'brown', 'blonde', 'red', 'white', 'gray'])"
            default: "str('red')"
      - method_name: "ask_eye_color"
        description: "Ask if the `answer` has a specific eye color."
        args:
          - name: "eye_color"
            description: "The eye color to ask about."
            increment: "lambda **kwargs: random.choice(['blue', 'green', 'brown'])"
            default: "str('blue')"
      - method_name: "ask_glasses"
        description: "Ask if the `answer` wears glasses."
        args: [ ]
    evaluation:
      increment: "lambda **kwargs: [random.choice(['ask_hair_color', 'ask_eye_color', 'ask_glasses', 'guess']) for _ in range(kwargs['x'] // 4)] + ['guess']"
      default: "['ask_hair_color', 'ask_eye_color', 'ask_glasses', 'guess']"

  - class_name: "Register"
    description: |
      You are given a class `Register` representing a register of student names (passed as strings).
      You must support functionality to `add` new names to the register, `remove` names from the register and `get_names` which returns a list with all names in the register.
      The implementation must follow that of a **Linked List**.
    difficulty: 4.5
    max_time: 30000
    init:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(2)"
        hidden: true
      - name: "names"
        increment: "lambda **kwargs: list({fake.first_name() for _ in range(kwargs['x'])})"
        default: "list(['Charlie'])"
        hidden: true
      - name: "name"
        description: "Initial name in the register."
        increment: "lambda **kwargs: random.choice(kwargs['names'])"
        default: "str('Charlie')"
    methods:
      - method_name: "add"
        description: "Add a name to the register."
        args:
          - name: "name"
            description: "The name to add to the register (could be a duplicate!)."
            increment: "lambda **kwargs: random.choice(kwargs['names'])"
            default: "str('Alice')"
      - method_name: "remove"
        description: "Remove a name from the register."
        args:
          - name: "name"
            description: "The name to remove from the register (if it exists)."
            increment: "lambda **kwargs: random.choice(kwargs['names'])"
            default: "str('Charlie')"
      - method_name: "get_names"
        description: "Get a list of all names in the register."
        args: [ ]
    evaluation:
      increment: "lambda **kwargs: [random.choice(['add', 'add', 'remove']) for _ in range(kwargs['x'] // 2)] + ['get_names']"
      default: "['add', 'remove', 'get_names']"

  - class_name: "Queue"
    description: |
      You are given a class `Queue` representing a queue of students (passed as string names).
      You must support functionality to `add` new names to the queue, `remove` names from the **front** of the queue and `get_names` which returns a list with all names in the queue.
    difficulty: 2.5
    max_time: 20000
    init:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(2)"
        hidden: true
      - name: "names"
        increment: "lambda **kwargs: list({fake.first_name() for _ in range(kwargs['x'])})"
        default: "list(['Charlie'])"
        hidden: true
      - name: "name"
        description: "Initial name in the queue."
        increment: "lambda **kwargs: random.choice(kwargs['names'])"
        default: "str('Charlie')"
    methods:
      - method_name: "add"
        description: "Add a student to the queue."
        args:
          - name: "name"
            description: "The name to add to the queue."
            increment: "lambda **kwargs: random.choice(kwargs['names'])"
            default: "str('Alice')"
      - method_name: "remove"
        description: |
          Remove the **first** student in the queue (should they exist). 
          Return the name of the student removed from the queue.
          **NOTE**: You **cannot** leave the queue empty. Attempting to remove *the last person* should return `None`.
        args: [ ]
      - method_name: "get_names"
        description: "Get a list of all names in the register."
        args: [ ]
    evaluation:
      increment: "lambda **kwargs: [random.choice(['add', 'remove']) for _ in range(kwargs['x'] // 2)] + ['get_names']"
      default: "['add', 'remove', 'get_names']"

  - class_name: "Stack"
    description: |
      You are given a class `Stack` representing a stack of parenthesis (passed as string names) such as `['(', '(', ')', '(']`.
      You must support functionality to `add` new parenthesis to the **top** of the stack and to `match` parenthesis from the **top** of the stack.
    difficulty: 3.0
    max_time: 20000
    init:
      - name: "x"
        increment: "lambda x: x + 1"
        default: "int(2)"
        hidden: true
      - name: "parentheses"
        increment: "lambda **kwargs: list({random.choice(['(', ')']) for _ in range(kwargs['x'])})"
        default: "list(['('])"
        hidden: true
      - name: "parenthesis"
        description: "Initial parenthesis in the queue."
        increment: "lambda **kwargs: random.choice(kwargs['parentheses'])"
        default: "str('(')"
    methods:
      - method_name: "add"
        description: "Add a parenthesis to the **top** of the stack."
        args:
          - name: "parenthesis"
            description: "The parenthesis to add to the stack."
            increment: "lambda **kwargs: random.choice(kwargs['parentheses'])"
            default: "str('(')"
      - method_name: "match"
        description: |
          Remove the parenthesis at the **top** of the stack.
          If the parenthesis at the top of the stack as a `(` and the parenthesis to match is a `)`, then the parenthesis are matched and you should return `True`.
          Otherwise, the parenthesis are not matched and you should return `False`.
          **NOTE**: Be aware that the stack *could remain empty* if you remove the last element.
        args:
          - name: "parenthesis"
            description: "The parenthesis to add to the stack."
            increment: "lambda **kwargs: random.choice(kwargs['parentheses'])"
            default: "str(')')"
    evaluation:
      increment: "lambda **kwargs: [random.choice(['add', 'match']) for _ in range(kwargs['x'])]"
      default: "['add', 'match', 'match']"




